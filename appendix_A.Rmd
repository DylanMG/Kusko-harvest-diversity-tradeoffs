---
title: ''
author: "B. Connors"
date: "July 23, 2019"
output:
  pdf_document: default
  keep_tex: yes
  html_document: default
editor_options:
  chunk_output_type: inline
fig_caption: true  
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(
  fig.path = "images/"
)
source("load.R")
```
####Appendix A: Stationary Ricker to cyclical Beverton-Holt spawner-recruit formulation

>Connors B. M., B. Staton, L. Coggins, C. Walters, M. Jones, D. Gwinn, M. Catalano and S. Fleischman. In preparation. Incorporating harvest-population diversity trade-offs into salmon management in large river basins: a case study of Kuskokwim River Chinook.

Our baseline simulations  assumed that recruitment dynamics are governed by a stationary Ricker-type spawner-recruitment relationship with overcompensation at high spawner abundances (equations 1-3 in main text). This is the state of nature that is currently assumed by fishery managers in the Kuskokwim and is also common assumed in other salmon systems. We also considered an alternative recruitment hypothesis that assumed that low frequency regime shifts gave rise to the appearance of overcompensation, when in fact none was present. Under this hypothesis we assumed that individual spawner-recruitment relationships were governed by Beverton-Holt dynamics with cyclical variation in population productivity (hereafter referred to as "BH_cycl").  

Equation 6 in the main text details the time-varying Beverton-Holt spawner-recruitment formulation. In addition to productivity at small population size ($\alpha$) and magnitude of density dependence ($\beta$) from equations 1-3, there are three additional terms required to parameterize the BH_cyl formulation: *f* and *A* which are the period and amplitude of time varying productivity, respectively, and  $\delta$ which is a scalar that adjusts productivity such that long-term population equilibrium abundance in the absence of fishing is approximately the same as those under the stationary Ricker spawner-recruitment formulation.

Figure 1 below illustrates a simulated spawner-recruit relationship generated by equation 6 with *f* = 14, *A* = 0.6,and $\delta$ = 1.4, along with a bunch of other assumptions (see full code for this doc [here](https://github.com/brendanmichaelconnors/Kusko-harvest-diversity-tradeoffs/blob/master/Appendix%20A.Rmd)). 


```{r ,include=FALSE}
# simulate a spawner-recruitment relationship assuming BH_cyl based on a draw from the posteriors of the model fit (and median alpha and beta)
# ricker_a <- log(7.17)
# ricker_b <- -0.0000098718
# sub = 125000
# egfloor = 50000
# 
# bh_sim_1 <- sr_sim(ny = 50,
#                phi = 0,
#                rec_sd = 0.35,
#                mat = c(0.15, 0.4, 0.4, 0.05),
#                alpha = exp(ricker_a),
#                beta = (ricker_b * -1),
#                U = 0.6,
#                OU = 0.1,
#                Spw = ricker_a/(ricker_b*-1),
#                Rec = rep(ricker_a/(ricker_b*-1),8),
#                SR_rel = "Beverton-Holt",
#                period = 14,
#                alpha.scalar = 1.4,
#                BH.alpha.CV = 0.6)

#saveRDS(bh_sim_1, "BH_sim1")

bh_sim_1 <- readRDS("outputs/BH_sim1")

spawners <- bh_sim_1 $S[10:50]
recruits <- bh_sim_1 $R[10:50]
  
BH_prod_col <- viridis(7)

time_prod_col <- c(BH_prod_col[1],
                   BH_prod_col,
                   rev(BH_prod_col),
                   BH_prod_col,
                   rev(BH_prod_col),
                   BH_prod_col,
                   rev(BH_prod_col))[1:41]

```



```{r  fig1, echo=FALSE, results="hide",fig.height = 3.25, fig.width = 5, fig.align = "center", dpi=400,fig.cap="**Figure 1.** Spawner-recruitment data simulated by a Beverton-Holt type relationship with time-varying productivity (colors). The black line is the Ricker type spawner-recruitment relationship estimated from the data, which implies that there is overcompensation when in fact there is none."}

split.screen(rbind(
c(0,1,0,1), #1
c(0.70,0.90,0.7,0.8) #2
))

screen(1)
par(mfrow=c(1,1),bty="o", mar=c(4,4,1,1))#set dimensions to plots

plot( x = spawners/1000,
      y = recruits/1000,
      xlim = c(0,400),
      ylim=c(0,700),
      ylab = "Recruits (000s)",
      xlab = "Spawners (000s)",
      yaxt = "n",
      pch = 16,
      cex = 1.5,
      col = time_prod_col)
axis(2,las=2)
box(col="grey")

ricker_fit <- lm(log(recruits/spawners)~spawners)
ricker_pred <- matrix(NA,100,1)
spawn <- seq(1,400000,length.out=100)
for (i in 1:100){ricker_pred[i] <- exp(ricker_fit$coefficients[1])*spawn[i]*exp(ricker_fit$coefficients[2]*spawn[i]) }

points(spawn/1000,ricker_pred/1000,type="l", lwd=2)
text(340, 610, "Time-varying productivity",cex=0.7)

screen(2)

par(mar=c(1,1,0,0))

legend.scale(c(0,1), 
             col = BH_prod_col,
             axis.args = list(at = c(0,1),
                              las = 1,
                              labels = c("low", "high"),
                              cex.axis = 0.55,
                              tck = 0.25,
                              padj = -3))

```


In order to simulate time-varying Beverton-Holt spawner-recruitment relationships with apparent overcompensation that approximate that observed in the Kuskokwim we first needed to determine what combination of *f*, *A* and $\delta$ should be used in our closed-loop simulations. What we wanted were combinations of the parameters that generate a spawner-recruit relationship that looks the same as the actual aggregate Kuskokwim relationship, but that arise from time-varying Beverton-Holt dynamics instead of overcompensation (i.e., Ricker assumption). To do this we simulated spawner-recruitment datasets using the BH_cyl formulation across a range of *f*, *A* and $\delta$. In each iteration of the simulation we fit a Ricker spawner-recruitment relationship to the data (i.e., ln(recruits/spawners)~spawners) and compared the estimates of intrinsic productivity ($\alpha$) and magnitude of density dependence ($\beta$) from the model fit to the true values. We did this 1000 times across twenty values of *f* (1-20), three level of *A* (0.2, 0.4, 0.6) and 20 values of $\delta$ (0.2-2).



```{r ,include=FALSE}

ricker_a <- log(7.17)
ricker_b <- -0.0000098718

sub = 200000
egfloor = 30000

ricker_para_dev <- array(NA,dim=c(2,20,20,7,20))

period <- seq(1,20,length.out=20)
alpha.scalar <- seq(0.2,2,length.out=20)
BH.alpha.CV <- c(0.2,0.3,0.4,0.5,0.6,0.7,0.8)

 
# for(w in 1:7){
#   for(k in 1:20){
#     for(j in 1:20){
#       for(i in 1:20){
#             bh_sim <- sr_sim(ny = 50,
#                              phi = 0,
#                              rec_sd = 0.2,
#                              mat = c(0.15, 0.4, 0.4, 0.05),
#                              alpha = exp(ricker_a),
#                              beta = (ricker_b * -1),
#                              U = 0.6,
#                              OU = 0.1,
#                              Spw = ricker_a/(ricker_b*-1),
#                              Rec = rep(ricker_a/(ricker_b*-1),8),
#                              SR_rel = "Beverton-Holt",
#                              period = period[k],
#                              alpha.scalar = alpha.scalar[j],
#                              BH.alpha.CV = BH.alpha.CV[w])
# 
#             spawners <- bh_sim$S[10:50]
#             recruits <- bh_sim$R[10:50]
# 
#             ricker_fit <- lm(log(recruits/spawners)~spawners)
#             ricker_para_dev[1, k, j, w, i] <- ricker_fit$coefficients[1]/ricker_a
#             ricker_para_dev[2, k, j, w, i] <- ricker_fit$coefficients[2]/ricker_b
# 
#            }
#        }
#   }
# }
# saveRDS(ricker_para_dev, "BH_sims")

sim_output <- readRDS("outputs/BH_sims")

xx <- apply(sim_output,c(1,2,3,4),quantile,probs=c(0.5),na.rm=T)

cv.0.2 <- xx[,1:20,1:20,1]
cv.0.4 <- xx[,1:20,1:20,3]
cv.0.6 <- xx[,1:20,1:20,5]
cv.0.8 <- xx[,1:20,1:20,7]
```

```{r  fig2, echo=FALSE, fig.height = 5, fig.width = 8, dpi=400,fig.align = "center", fig.cap="**Figure 2.** Effects of *f* (y-axis), *A* (panels) and alpha scalar (x-axis) on model based (Ricker) estimates of instrinsic productivty (top row) and magnitue of density dependence (bottom row) fit to simulated spawner-recruit data from a model with time-varying Beverton-Holt relationship. The Z-axis is the median magnitude of proportional error (i.e., estimated / true) across 1000 trials for each combination of *f*, *A* and alpha scalar."}

par(mfrow=c(2,3),bty="o", mar=c(2,2,2,2.5),oma=c(2,2,1,1.5))

# panel a - A = 0.2
  xx<-as.table(cv.0.2[1,,])
  colnames(xx)<-(alpha.scalar[1:20])
  rownames(xx)<-(period[1:20])
  long.data <- as.data.frame(xx)
  x <- as.numeric(paste(long.data[,1]))
  y <- as.numeric(paste(long.data[,2]))
  z <-as.numeric(long.data[,3])
  data.loess = loess(z~x*y)
  grid = expand.grid(list(x = period[1:20], y = alpha.scalar[1:20]))
  zz<-as.matrix(predict(data.loess, newdata = grid))
  xx<-alpha.scalar[1:20]
  yy<-period[1:20]
  
  image(xx,yy,zz,axes=F,ylab="",xlab="",col=rev(viridis(100)),zlim = c(0.1,1.2))
    axis(1,labels=F)
    axis(2,las=2)
  text(0.45, 18.5,expression(paste(italic("A"),"= 0.2")),col="white", cex = 1.25)
  #image.plot(xx,yy,zz,axes=F,add=T,legend.mar=3,col=rev(viridis(100)),legend.width = 2, zlim = c(0.2,1.2))
    box(col="black")
  
# panel b - A = 0.4
  xx<-as.table(cv.0.4[1,,])
  colnames(xx)<-(alpha.scalar[1:20])
  rownames(xx)<-(period[1:20])
  long.data <- as.data.frame(xx)
  x <- as.numeric(paste(long.data[,1]))
  y <- as.numeric(paste(long.data[,2]))
  z <-as.numeric(long.data[,3])
  data.loess = loess(z~x*y)
  grid = expand.grid(list(x = period[1:20], y = alpha.scalar[1:20]))
  zz<-as.matrix(predict(data.loess, newdata = grid))
  xx<-alpha.scalar[1:20]
  yy<-period[1:20]
  
  image(xx,yy,zz,axes=F,ylab="",xlab="",col=rev(viridis(100)),zlim = c(0.1,1.2))
    axis(1,labels=F)
    axis(2,las=2,labels=F)
  text(0.45, 18.5,expression(paste(italic("A"),"= 0.4")),col="white", cex = 1.25)
  mtext(expression(paste(alpha," (estimated / true)")),3,cex=1.1,line=0.65,adj=0.5)
  #image.plot(xx,yy,zz,axes=F,add=T,legend.mar=3,col=rev(viridis(100)),legend.width = 2, zlim = c(0.2,1.2))
    box(col="black")
    
# panel c - A = 0.6
  xx<-as.table(cv.0.6[1,,])
  colnames(xx)<-(alpha.scalar[1:20])
  rownames(xx)<-(period[1:20])
  long.data <- as.data.frame(xx)
  x <- as.numeric(paste(long.data[,1]))
  y <- as.numeric(paste(long.data[,2]))
  z <-as.numeric(long.data[,3])
  data.loess = loess(z~x*y)
  grid = expand.grid(list(x = period[1:20], y = alpha.scalar[1:20]))
  zz<-as.matrix(predict(data.loess, newdata = grid))
  xx<-alpha.scalar[1:20]
  yy<-period[1:20]
  
  image(xx,yy,zz,axes=F,ylab="",xlab="",col=rev(viridis(100)), zlim = c(0.1,1.2))
    axis(1,labels=F)
    axis(2,las=2,labels=F)
  image.plot(xx,yy,zz,axes=F,add=T,legend.mar=3,col=rev(viridis(100)),legend.width = 2, zlim = c(0.1,1.2))
  text(0.45, 18.5,expression(paste(italic("A"),"= 0.6")),col="white", cex = 1.25)
    box(col="black")


# panel d - A = 0.1
  xx<-as.table(cv.0.2[2,,])
  colnames(xx)<-(alpha.scalar[1:20])
  rownames(xx)<-(period[1:20])
  long.data <- as.data.frame(xx)
  x <- as.numeric(paste(long.data[,1]))
  y <- as.numeric(paste(long.data[,2]))
  z <-as.numeric(long.data[,3])
  data.loess = loess(z~x*y)
  grid = expand.grid(list(x = period[1:20], y = alpha.scalar[1:20]))
  zz<-as.matrix(predict(data.loess, newdata = grid))
  xx<-alpha.scalar[1:20]
  yy<-period[1:20]
  
  image(xx,yy,zz,axes=F,ylab="",xlab="",col=rev(viridis(100)), zlim = c(0.4,2.5))
    axis(1)
    axis(2,las=2)
  text(0.45, 18.5,expression(paste(italic("A"),"= 0.2")),col="black", cex = 1.25)
  #image.plot(xx,yy,zz,axes=F,add=T,legend.mar=3,col=rev(viridis(100)),legend.width = 2, zlim = c(0.4,2))
    box(col="black")
  
# panel e - A = 0.4
  xx<-as.table(cv.0.4[2,,])
  colnames(xx)<-(alpha.scalar[1:20])
  rownames(xx)<-(period[1:20])
  long.data <- as.data.frame(xx)
  x <- as.numeric(paste(long.data[,1]))
  y <- as.numeric(paste(long.data[,2]))
  z <-as.numeric(long.data[,3])
  data.loess = loess(z~x*y)
  grid = expand.grid(list(x = period[1:20], y = alpha.scalar[1:20]))
  zz<-as.matrix(predict(data.loess, newdata = grid))
  xx<-alpha.scalar[1:20]
  yy<-period[1:20]
  
  image(xx,yy,zz,axes=F,ylab="",xlab="",col=rev(viridis(100)), zlim = c(0.4,2.5))
    axis(1)
    axis(2,las=2,labels=F)
  mtext(expression(paste(beta," (estimated / true)")),3,cex=1.1,line=0.65,adj=0.5)
  text(0.44, 18.5,expression(paste(italic("A"),"= 0.4")),col="black", cex = 1.25)
  #image.plot(xx,yy,zz,axes=F,add=T,legend.mar=3,col=rev(viridis(100)),legend.width = 2, zlim = c(0.4,2))
    box(col="black")
    
# panel f - A = 0.6
  xx<-as.table(cv.0.6[2,,])
  colnames(xx)<-(alpha.scalar[1:20])
  rownames(xx)<-(period[1:20])
  long.data <- as.data.frame(xx)
  x <- as.numeric(paste(long.data[,1]))
  y <- as.numeric(paste(long.data[,2]))
  z <-as.numeric(long.data[,3])
  data.loess = loess(z~x*y)
  grid = expand.grid(list(x = period[1:20], y = alpha.scalar[1:20]))
  zz<-as.matrix(predict(data.loess, newdata = grid))
  xx<-alpha.scalar[1:20]
  yy<-period[1:20]
  
  image(xx,yy,zz,axes=F,ylab="",xlab="",col=rev(viridis(100)))
    axis(1)
    axis(2,las=2,labels=F)
  image.plot(xx,yy,zz,axes=F,add=T,legend.mar=3,col=rev(viridis(100)),legend.width = 2, zlim = c(0.4,3.5))
  text(0.45, 18.5,expression(paste(italic("A"),"= 0.6")),col="black",cex=1.25)
    box(col="black")


mtext(expression(paste("Alpha scalar ","(",delta,")")),1,outer=T,cex=1.1,line=1)
mtext(expression(paste("Period ","(",italic("f"),")")),side=2,outer=T,cex=1.1,line=0.4)             
```

Figure 2 suggest that, generally speaking, estimates of $\alpha$ are biased low at periods (*f*) less than 10 years, but were otherwise relatively unbiased across a range of values in *A* and $\delta$. Estimates of $\beta$ were more sensitive to parameter combinations, but generally appeared to be the least biased when the period (*f*), amplitude (*A*) and productivity scalar ($\delta$) were approximately 14, 0.6 and 1.4, respectively. 

We then further explored the extent to which this combination of parameter values generates an apparent spawner-recruit relationship that qualitatively matches the empirical Kuskokwim one. To do this we simulated 1000 spawner-recruitent datasets under the BH_cycl formulation with the period (*f*), amplitude (*A*) and productivity scalar ($\delta$) equal to 14, 0.6 and 1.4, respectively (Figure 3B illustrates the resulting time-series of productivity). For each simulation we then fit a Ricker spawner-recruitment relationship to the data and then summarized the predicted relationship across the 1000 sumulations relative to the observed Ricker spawner-recruitment relationship for the Kuskokwim aggregate (Figure 3A). These simulations suggests that this combination of parameter values result in a spawner-recruitment relationship with apparent overcompensation of a magnitude similar to that observerd in the Kuskokwim.   

```{r  fig3, echo=FALSE, fig.height = 3, fig.width = 8, fig.align = "center", dpi=400, fig.cap="**Figure 3.**(A) Observed (Ricker black line) spawner-recruitment relationship in the Kuskokwim and simulated relationship (median and 95th percentiles) assuming a Beverton-Holt spawner-recruitment relationhsip with time-varying productivity (B)."}

ricker_a <- log(7.17)
ricker_b <- -0.0000098718
sub = 200000
egfloor = 30000

ricker_para <- array(NA,dim=c(2,1000))
ricker_pred <- matrix(NA,1000,100)

for(i in 1:1000){
  bh_sim_1 <- sr_sim(ny = 50,
                 phi = 0,
                 rec_sd = 0.5,
                 mat = c(0.15, 0.4, 0.4, 0.05),
                 alpha = exp(ricker_a),
                 beta = (ricker_b * -1),
                 U = 0.6,
                 OU = 0.1,
                 Spw = ricker_a/(ricker_b*-1),
                 Rec = rep(ricker_a/(ricker_b*-1),8),
                 SR_rel = "Beverton-Holt",
                 period = 14,
                 alpha.scalar = 1.395,
                 BH.alpha.CV = 0.6)

  spawners <- bh_sim_1 $S[10:50]
  recruits <- bh_sim_1 $R[10:50]

  ricker_fit <- lm(log(recruits/spawners)~spawners)
  ricker_para[1,i] <- ricker_fit$coefficients[1]
  ricker_para[2,i] <- ricker_fit$coefficients[2]
  
  spawn <- seq(1,300000,length.out=100)
  for (j in 1:100){ricker_pred[i,j] <- exp(ricker_para[1,i] )*spawn[j]*exp(ricker_para[2,i]*spawn[j]) }
  
}
rec.pred <- apply(ricker_pred,c(2),quantile,probs=c(0.5,0.2,0.8),na.rm=T)

BH_prod <- bh_sim_1$BH_prod[10:50]
BH_prod_col <- viridis(7)

time_prod_col <- c(BH_prod_col[1],
                   BH_prod_col,
                   rev(BH_prod_col),
                   BH_prod_col,
                   rev(BH_prod_col),
                   BH_prod_col,
                   rev(BH_prod_col))[1:41]

###
ricker_pred_k <- matrix(NA,100,1)
spawn <- seq(1,300000,length.out=100)
for (i in 1:100){ricker_pred_k[i] <- exp(ricker_a )*spawn[i]*exp(ricker_b*spawn[i]) }


par(mfrow=c(1,2),bty="o", mar=c(4,4,1,1))#set dimensions to plots

# panel a
  plot( x = seq(10:50),
        y = BH_prod,
        type = "l",
        lwd = 2,
        ylab = "Productivity",
        xlab = "Time",
        yaxt = "n",
        col="grey",
        ylim=c(1,17))
  
  axis(2,las=2)
  box(col="grey")
  
  points(seq(10:50),
         BH_prod,
         col=time_prod_col,
         pch=16)
  text(2,16,"(a)",cex=0.95)

# panel b
  plot( x = spawn/1000,
        y = ricker_pred_k/1000,
        type = "l",
        lwd = 2,
        ylab = "Recruits (000s)",
        xlab = "Spawners (000s)",
        yaxt = "n",
        ylim = c(0,350))
  axis(2,las=2)
  box(col="grey")

  polygon(c(spawn/1000,rev(spawn/1000)),c(rec.pred[2,]/1000,rev(rec.pred[3,]/1000)),col=adjustcolor( "red", alpha.f = 0.1),lty=2,border=NA)

    
  points(spawn/1000,
         rec.pred[1,]/1000,
         type="l",
         col="red",
         lwd=2)
  
  legend(70,370,
         c("Ricker","Time-varying Beverton-Holt"),
         lwd=2,
         col=c("black","red"),
         cex=0.75, 
         bty="n")
  text(5,335,"(b)",cex=0.95)
  


```